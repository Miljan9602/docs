---
title: "Get Quote"
api: "POST https://your-solver.example.com/api/v1/quote"
---

<Note>
  This endpoint is called by the RFQ Coordinator to request a price quote from the solver. Solvers must implement this endpoint.
</Note>

Returns a price quote for a specific token swap request.

## Headers

<ParamField header="Authorization" type="string" required>
  Bearer token for authentication: `Bearer <auth_key>`
</ParamField>

## Request Body

<ParamField body="input_token" type="string" required>
  The token address to sell (0x-prefixed)
</ParamField>

<ParamField body="output_token" type="string" required>
  The token address to buy (0x-prefixed)
</ParamField>

<ParamField body="amount" type="string" required>
  Amount to swap in wei (as a numeric string)
</ParamField>

<ParamField body="chain_id" type="string" required>
  The blockchain chain ID
</ParamField>

<ParamField body="expiry_timestamp" type="number" required>
  Unix timestamp (milliseconds) for quote expiry.
</ParamField>

## Response

<ResponseField name="status" type="string">
  Response status: `"ok"` on success, `"error"` on failure
</ResponseField>

<ResponseField name="quote_id" type="string">
  Unique quote identifier generated by the solver
</ResponseField>

<ResponseField name="input_token" type="string">
  The input token address
</ResponseField>

<ResponseField name="output_token" type="string">
  The output token address
</ResponseField>

<ResponseField name="amount_in" type="string">
  Amount of input tokens (in wei)
</ResponseField>

<ResponseField name="amount_out" type="string">
  Amount of output tokens to provide (in wei)
</ResponseField>

<ResponseField name="expiry" type="number">
  Unix timestamp (milliseconds) when the quote expires.
</ResponseField>

<ResponseField name="chain_id" type="string">
  The chain ID
</ResponseField>

<RequestExample>
```bash cURL
curl -X POST "https://solver.example.com/api/v1/quote" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer your_auth_key" \
  -d '{
    "input_token": "0x...",
    "output_token": "0x...",
    "amount": "1000000000",
    "chain_id": "<CHAIN_ID>",
    "expiry_timestamp": 1705612830000
  }'
```
</RequestExample>

<ResponseExample>
```json 200 - Success
{
  "status": "ok",
  "quote_id": "rfq-q-550e8400-e29b-41d4-a716-446655440000",
  "input_token": "0x3894085ef7ff0f0aedf52e2a2704928d1ec074f1",
  "output_token": "0xe30fedd158a2e3b13e9badaeabafc5516e95e8c7",
  "amount_in": "1000000000",
  "amount_out": "498500000000000000",
  "expiry": 1705612830000,
  "chain_id": "1329"
}
```

```json 400 - Validation Error
{
  "status": "error",
  "error": "amount: Expected string",
  "code": "VALIDATION_INVALID_PARAM"
}
```

```json 400 - Market Not Found
{
  "status": "error",
  "error": "Market does not exist",
  "code": "MARKET_NOT_FOUND"
}
```
</ResponseExample>

## WSS Equivalent

For WebSocket solvers, the coordinator sends a `get_quote` message and expects a `quote_response`.

**Request (Coordinator -> Solver):**
```json
{
  "action": "get_quote",
  "request_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "data": {
    "quote_id": "550e8400-e29b-41d4-a716-446655440000",
    "chain_id": "1329",
    "input_token": "0xe30fedd158a2e3b13e9badaeabafc5516e95e8c7",
    "output_token": "0xe15fc38f6d8c56af07bbcbe3baf5708a2bf42392",
    "amount": "1000000000000000000",
    "expiry_timestamp": 1738780830000
  }
}
```

**Response (Solver -> Coordinator):**
```json
{
  "action": "quote_response",
  "request_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "success": true,
  "data": {
    "quote_id": "550e8400-e29b-41d4-a716-446655440000",
    "amount_out": "249250000",
    "expiry": 1738780830000,
    "chain_id": "1329"
  }
}
```

<Warning>
  The `expiry` field **must be a number** (integer), not a string. The coordinator validates `quote_id`, `amount_out`, and `expiry` from the response.
</Warning>

## Implementation Example

```typescript
import { successResponse, errorResponse, ErrorCodes } from "rfq-api";

app.post("/api/v1/quote", async (req, res) => {
  const { input_token, output_token, amount, chain_id, expiry_timestamp } = req.body;

  // Validate inputs
  if (!isValidAddress(input_token) || !isValidAddress(output_token)) {
    return res.status(400).json(
      errorResponse("Invalid token address", ErrorCodes.VALIDATION_INVALID_ADDRESS)
    );
  }

  try {
    // Get current prices
    const inputPrice = await getTokenPrice(input_token);
    const outputPrice = await getTokenPrice(output_token);

    // Calculate output amount with spread
    const amountBigInt = BigInt(amount);
    const fairValue = (amountBigInt * inputPrice) / outputPrice;
    const spread = 5n; // 0.05% spread in basis points
    const amountOut = fairValue - (fairValue * spread) / 10000n;

    res.json(
      successResponse({
        quote_id: `rfq-q-${crypto.randomUUID()}`,
        input_token,
        output_token,
        amount_in: amount,
        amount_out: amountOut.toString(),
        expiry: expiry_timestamp,
        chain_id,
      })
    );
  } catch (error) {
    res.status(400).json(
      errorResponse("Market does not exist", ErrorCodes.MARKET_NOT_FOUND)
    );
  }
});
```

## Pricing Considerations

<AccordionGroup>
  <Accordion title="Spread Calculation">
    Apply a spread to cover your risk and earn profit:
    ```typescript
    const spreadBps = 5n; // 0.05%
    const amountOut = fairValue - (fairValue * spreadBps) / 10000n;
    ```
  </Accordion>

  <Accordion title="TTL by Volatility">
    The coordinator sends `expiry_timestamp` based on market configuration:
    | Market Type | TTL | Reason |
    |-------------|-----|--------|
    | Volatile (ETH/USDC) | 15 seconds | High price volatility |
    | Stable (USDC/USDT) | 30 seconds | Price is relatively stable |
  </Accordion>

  <Accordion title="Price Feeds">
    Use reliable price sources:
    - On-chain oracles (Chainlink, Pyth)
    - DEX prices (DragonSwap, Uniswap)
    - CEX APIs (for reference)
  </Accordion>
</AccordionGroup>

## Notes

- Store the `quote_id` to validate when receiving intent requests
- Use the `expiry_timestamp` from the request as your `expiry` in the response
- Ensure you have sufficient balance of output tokens before quoting
- The RFQ Coordinator may request multiple quotes in parallel - handle concurrency
